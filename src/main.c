/*
 ******************************************************************************
 File:     main.c
 Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2021-04-09

 The MIT License (MIT)
 Copyright (c) 2019 STMicroelectronics

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

 ******************************************************************************
 */

/* Includes */
//#include "stm32f4xx.h"
//#include "stm32f429i_discovery.h"
//#include "math.h"
#include "init.h"
#include "pantalla_lcd.h"
#include "stm32f4xx.h"
#include "stm32f429i_discovery.h"
#include "stm32f429i_discovery_lcd.h"
#include "bufferCircular.h"

/* Private macro */
/* Private variables */
/* Private function prototypes */
/* Private functions */

/**
 **===========================================================================
 **
 **  Abstract: main program
 **
 **===========================================================================
 */

/*
 * circunferencia = perimetre = 2m
 * 11,11m/s = 5,555 voltes/s -> Tp = 0,005625 s
 * 75m/s = 37,5 voltes/s -> Tp = 0.0008333 s
 *
 */

volatile unsigned short tempsInt = 0;
volatile static double velOut = 0;
volatile static double velOut2 = 1;
volatile static int rTime = 0;				//for the right wheel pwm
volatile static int lTime = 0;				//for the left wheel pwm
volatile static float Wl = 0;
volatile static float Wr = 0;
volatile static char mottor = 'r';
volatile static char numConversion = 0;
volatile static float finalValue1;
volatile static float finalValue2;
volatile static char fase3 = 0;
static bufferCircular dataBufferX;
static bufferCircular dataBufferY;

void DMA2_Stream0_IRQHandler(void){
	if(DMA_GetITStatus(DMA2_Stream0, DMA_IT_TCIF0)) {
		DMA_ClearITPendingBit(DMA2_Stream0, DMA_IT_TCIF0);

		if(!numConversion)
			DMA_Cmd(DMA2_Stream1, ENABLE);
	}
}

void DMA2_Stream1_IRQHandler(void){
	if(DMA_GetITStatus(DMA2_Stream1, DMA_IT_TCIF1)) {
		DMA_ClearITPendingBit(DMA2_Stream1, DMA_IT_TCIF1);
		float average = 0;
		float average2 = 0;
		int i = 0;

		for(i = 0; i < 8; i++){
			average += finalData[i*2];
			average2 += finalData[(i*2)+1];
		}

		average /= 8;
		average /= 1365.3;	//para combertiro a voltios
		average2 /= 8;
		average2 /= 1365.3;

		//y = 0.25x + 1
		finalValue1 = (average*4) - 4;
		finalValue2 = (average2*4) - 4;
	}
}

void TIM1_BRK_TIM9_IRQHandler(void){
	if (TIM_GetITStatus(TIM9, TIM_IT_Update) != RESET) {
		TIM_ClearITPendingBit(TIM9, TIM_IT_Update);
		numConversion++;
		ADC_SoftwareStartConv(ADC1);

		if(numConversion == 8){
			init_TIM6_OFF();
			numConversion = 0;
		}
	}
}

void TIM5_IRQHandler(void) {
	if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET) {
		//TIM6->CNT = 0;
		static char value2 = 1;
		TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
		rTime++;
		lTime++;

		value2 = value2 == 1 ? 0 : 1;

		if(rTime == 2000000){
			Wr = 0;
		}
		if(lTime == 2000000){
			Wl = 0;
		}
		//int josejuan = TIM6->CNT;
		//josejuan++;
	}
}

void init_motor_speed_timer(void) {
	TIM_TimeBaseInitTypeDef TIM_BaseStruct;

	/* Enable clock for TIM4 */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
	/*90 Mhz */

	/*
	 TIM4 is connected to APB1 bus, which has on F407 device --MHz clock
	 But, timer has internal PLL, which double this frequency for timer, up to 90MHz
	 Remember: Not each timer is connected to APB1, there are also timers connected
	 on APB2, which works at 90MHz by default, and internal PLL increase
	 this to up to 180MHz

	 Set timer prescaller
	 Timer count frequency is set with

	 timer_tick_frequency = Timer_default_frequency / (prescaller_set + 1)

	 In our case, we want a max frequency for timer, so we set prescaller to 0
	 And our timer will have tick frequency

	 timer_tick_frequency = 90000000 / (1125 -1 + 1) = 80000
	 */

	TIM_BaseStruct.TIM_Prescaler = 1125 - 1;
	TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;
	/*
	 Set timer period when it have reset
	 First you have to know max value for timer
	 In our case it is 16bit = 65535 -------------------------------?? ni idea XD
	 To get your frequency for PWM, equation is simple

	 PWM_frequency = timer_tick_frequency / (TIM_Period + 1)

	 If you know your PWM frequency you want to have timer period set correct

	 TIM_Period = timer_tick_frequency / PWM_frequency - 1

	 In our case, for 1.20Khz PWM_frequency (ma o meno) , set Period to

	 TIM_Period = 80000 / (1200 -> 177.7) = 66.666 -> 450

	 If you get TIM_Period larger than max timer value (in our case 65535),
	 you have to choose larger prescaler and slow down timer tick frequency
	 */
	if(velOut != 0){
		if (mottor == 'r') {
			TIM_BaseStruct.TIM_Period = round(
					(((double) 80000)
							/ ((double) (32 * ((velOut * velOut2) / (double) 2)))));
		} else {
			TIM_BaseStruct.TIM_Period = round(
					(((double) 80000) / ((double) (32 * ((velOut) / (double) 2)))));
		}
	}else{
		TIM_BaseStruct.TIM_Period = 0;
	}

	TIM_BaseStruct.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_BaseStruct.TIM_RepetitionCounter = 0;
	/* Initialize TIM4 */
	TIM_TimeBaseInit(TIM4, &TIM_BaseStruct);
	/* Start count on TIM4 */
	TIM_Cmd(TIM4, ENABLE);
}

void init_motor_speed_timer2(void) {
	TIM_TimeBaseInitTypeDef TIM_BaseStruct;

	/* Enable clock for TIM4 */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
	/*90 Mhz */

	/*
	 TIM4 is connected to APB1 bus, which has on F407 device --MHz clock
	 But, timer has internal PLL, which double this frequency for timer, up to 90MHz
	 Remember: Not each timer is connected to APB1, there are also timers connected
	 on APB2, which works at 90MHz by default, and internal PLL increase
	 this to up to 180MHz

	 Set timer prescaller
	 Timer count frequency is set with

	 timer_tick_frequency = Timer_default_frequency / (prescaller_set + 1)

	 In our case, we want a max frequency for timer, so we set prescaller to 0
	 And our timer will have tick frequency

	 timer_tick_frequency = 90000000 / (1125 -1 + 1) = 80000
	 */

	TIM_BaseStruct.TIM_Prescaler = 1125 - 1;
	TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;
	/*
	 Set timer period when it have reset
	 First you have to know max value for timer
	 In our case it is 16bit = 65535 -------------------------------?? ni idea XD
	 To get your frequency for PWM, equation is simple

	 PWM_frequency = timer_tick_frequency / (TIM_Period + 1)

	 If you know your PWM frequency you want to have timer period set correct

	 TIM_Period = timer_tick_frequency / PWM_frequency - 1

	 In our case, for 1.20Khz PWM_frequency (ma o meno) , set Period to

	 TIM_Period = 80000 / (1200 -> 177.7) = 66.666 -> 450

	 If you get TIM_Period larger than max timer value (in our case 65535),
	 you have to choose larger prescaler and slow down timer tick frequency
	 */
	if(velOut != 0){
		if (mottor == 'r') {
			TIM_BaseStruct.TIM_Period = round(
					(((double) 80000) / ((double) (32 * ((velOut) / (double) 2)))));
		} else {
			TIM_BaseStruct.TIM_Period = round(
					(((double) 80000)
							/ ((double) (32 * ((velOut * velOut2) / (double) 2)))));
		}
	}else{
		TIM_BaseStruct.TIM_Period = 0;
	}
	TIM_BaseStruct.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_BaseStruct.TIM_RepetitionCounter = 0;
	/* Initialize TIM4 */
	TIM_TimeBaseInit(TIM3, &TIM_BaseStruct);
	/* Start count on TIM4 */
	TIM_Cmd(TIM3, ENABLE);
}

void TM_PWM_Init(void) {
	TIM_OCInitTypeDef TIM_OCStruct;

	/* Common settings */

	/* PWM mode 2 = Clear on compare match */
	/* PWM mode 1 = Set on compare match */
	TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCStruct.TIM_OCPolarity = TIM_OCPolarity_Low;

	/*
	 To get proper duty cycle, you have simple equation

	 pulse_length = ((TIM_Period + 1) * DutyCycle) / 100 - 1

	 where DutyCycle is in percent, between 0 and 100%

	 50% duty cycle:     pulse_length = ((8399 + 1) * 50) / 100 - 1 = 4199

	 Remember: if pulse_length is larger than TIM_Period, you will have output HIGH all the time
	 */
	if(velOut != 0){
		if (mottor == 'r') {
			TIM_OCStruct.TIM_Pulse =
					(((((double) 80000)
							/ ((double) (32 * ((velOut * velOut2) / (double) 2))))
							+ 1) * 50) / (100 - 1); /* 50% duty cycle */
		} else {
			TIM_OCStruct.TIM_Pulse = (((((double) 80000)
					/ ((double) (32 * ((velOut) / (double) 2)))) + 1) * 50)
					/ (100 - 1); /* 50% duty cycle */
		}
	}else{
		TIM_OCStruct.TIM_Pulse = 0;
	}

	TIM_OC1Init(TIM4, &TIM_OCStruct);
	TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
}

void TM_PWM_Init2(void) {
	TIM_OCInitTypeDef TIM_OCStruct;

	/* Common settings */

	/* PWM mode 2 = Clear on compare match */
	/* PWM mode 1 = Set on compare match */
	TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCStruct.TIM_OCPolarity = TIM_OCPolarity_Low;

	/*
	 To get proper duty cycle, you have simple equation

	 pulse_length = ((TIM_Period + 1) * DutyCycle) / 100 - 1

	 where DutyCycle is in percent, between 0 and 100%

	 50% duty cycle:     pulse_length = ((8399 + 1) * 50) / 100 - 1 = 4199

	 Remember: if pulse_length is larger than TIM_Period, you will have output HIGH all the time
	 */
	if(velOut != 0){
		if (mottor != 'r') {
			TIM_OCStruct.TIM_Pulse =
					(((((double) 80000)
							/ ((double) (32 * ((velOut * velOut2) / (double) 2))))
							+ 1) * 50) / (100 - 1); /* 50% duty cycle */
		} else {
			TIM_OCStruct.TIM_Pulse = (((((double) 80000)
					/ ((double) (32 * ((velOut) / (double) 2)))) + 1) * 50)
					/ (100 - 1); /* 50% duty cycle */
		}
	}else{
		TIM_OCStruct.TIM_Pulse = 0;
	}
	TIM_OC3Init(TIM3, &TIM_OCStruct);
	TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Enable);
}

void EXTI2_IRQHandler(void) {	//right motor
	/* Make sure that interrupt flag is set */
	if (EXTI_GetITStatus(EXTI_Line2) != RESET) {
		EXTI_ClearITPendingBit(EXTI_Line2);
		Wr = (float) ((float) 1 / (float) (32 * 0.000002f * ((float) rTime)));
		rTime = 0;
	}
}

void EXTI4_IRQHandler(void) {	//left motor
	/* Make sure that interrupt flag is set */
	if (EXTI_GetITStatus(EXTI_Line4) != RESET) {
		EXTI_ClearITPendingBit(EXTI_Line4);
		Wl = (float) ((float) 1 / (float) (32 * 0.000002f * ((float) lTime)));
		lTime = 0;
	}
}

void TIM2_IRQHandler(void) {
	if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) {
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);

		init_TIM6_ON();
		static unsigned char timePepe = 0;
		static char ledOn = 0;

		fase3++;

		/* LED ON 200 ms -> LED off 200ms */

		if (timePepe == 199) {
			timePepe = 0;

			if (ledOn) {
				STM_EVAL_LEDOff(LED4);
			} else {
				STM_EVAL_LEDOn(LED4);
			}

			ledOn = !ledOn;

		} else {
			timePepe++;
		}

		static unsigned char state = 0;
		static signed char upDown = 1;
		static signed char upDown2 = 1;
		if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)) {
			if (state == 0) {
				char iscle = GPIO_ReadInputDataBit(GPIOF, GPIO_Pin_9);
				if (iscle) {
					if (state == 0) {
						state = 1;
						if (velOut == 0) { // 0 km/h
							if (upDown > 0) {
								velOut = 2.777;
							} else {
								velOut = 2.777;
								upDown = 1;
							}
							goto ENDSWITCH;
						} else if (velOut == 2.777) { // 10 km/h
							if (upDown > 0) {
								velOut = 9.722;
							} else {
								velOut = 0;
							}
							goto ENDSWITCH;
						} else if (velOut == 9.722) { // 35 km/h
							if (upDown > 0) {
								velOut = 12.5;
							} else {
								velOut = 2.777;
							}
							goto ENDSWITCH;
						} else if (velOut == 12.5) {	// 45 km/h
							if (upDown > 0) {
								velOut = 27.777;
							} else {
								velOut = 9.722;
							}
							goto ENDSWITCH;
						} else if (velOut == 27.777) {
							if (upDown > 0) {
								velOut = 75;
							} else {
								velOut = 12.5;
							}
							goto ENDSWITCH;
						} else if (velOut == 75) {
							velOut = 27.777;
							upDown = -1;
							goto ENDSWITCH;
						}

						STM_EVAL_LEDOn(LED3);	//error probablement de decimals
						velOut = 0;

					}
				} else {
					if (velOut2 == 1) {
						if (upDown2 > 0) {
							velOut2 = 1.25;
						} else {
							velOut2 = 1.25;
							upDown2 = 1;
						}
						goto ENDSWITCH2;
					} else if (velOut2 == 1.25) {
						if (upDown2 > 0) {
							velOut2 = 1.35;
						} else {
							velOut2 = 1.0f;
							mottor = mottor == 'r' ? 'l' : 'r';
						}
						goto ENDSWITCH2;
					} else if (velOut2 == 1.35) {
						if (upDown2 > 0) {
							velOut2 = 1.8;
						} else {
							velOut2 = 1.25;
						}
						goto ENDSWITCH2;
					} else if (velOut2 == 1.8) {
						if (upDown2 > 0) {
							velOut2 = 2.2;
						} else {
							velOut2 = 1.35;
						}
						goto ENDSWITCH2;
					} else if (velOut2 == 2.2) {
						velOut2 = 1.8;
						upDown2 = -1;
						goto ENDSWITCH2;
					}

					STM_EVAL_LEDOn(LED3);	//error probablement de decimals
					velOut2 = 1.0f;

					ENDSWITCH2:		//tornem a carregar els valors
					ENDSWITCH:
					init_motor_speed_timer2();
					TM_PWM_Init2();
					init_motor_speed_timer();
					TM_PWM_Init();
				}

				//tempsInt = TIM6->CNT;

			}

		} else {
			state = 0;
		}

		float speed = 0;
		float diferencia = 0;
		unsigned char value = 255 / 2;
		char right = 'r';

		if(Wr == 0 || Wl == 0){
			speed = 0;
			diferencia = 0;
		}else{
			if (Wr > Wl) {
				speed = Wl;
				right = 'r';
				diferencia = ((float) (Wr - Wl)) / (float) Wl;
			} else {
				speed = Wr;
				right = 'l';
				diferencia = ((float) (Wl - Wr)) / (float) Wr;
			}
		}

		//Wl = 0;
		//Wr = 0;

		//VFS = 3V

		if (speed * 2 >= 11.11) {//voltes/s * perimetre de la roda >= 11.11ms/s (40km/h)
			if (diferencia < 0.3) {
				// VFS/2
				DAC_SetChannel2Data(DAC_Align_8b_R, 127);
			}else if (diferencia < 1) {
				if (right == 'r') {
					value = round((((float) (2.14f * diferencia)) + 0.858) * ((float) 255 / (float) 3));//y = 2.14x + 0.858		calcul del pendent
					DAC_SetChannel2Data(DAC_Align_8b_R, value);
				} else {
					value = round((((float) (-2.14f * diferencia)) + 2.142) * ((float) 255 / (float) 3));//y = -2.14x + 2.142		calcul del pendent
					DAC_SetChannel2Data(DAC_Align_8b_R, value);
				}

			} else if (right == 'r') {
				DAC_SetChannel2Data(DAC_Align_8b_R, 255);
			} else {
				DAC_SetChannel2Data(DAC_Align_8b_R, 0);
			}
		} else {
			//Vfs/2
			DAC_SetChannel2Data(DAC_Align_8b_R, 127);
		}
		int josejuan = TIM6->CNT;
		josejuan++;
	}
}

/*
 * PF9: gnd - speed difference / vcc - speed++
 * PB2: rising edge interrupt right motor
 * PB4: rising edge interrupt left motor
 * PA5: DAC
 * PD12: pwm out 3v
 * PC6: pwm out 3v
 * PC3: ADC 1 channel_13
 * PC1: ADC 2 channel_10
 * PA0: button
 */

int main(void) {
	SystemInit();
	init_DAC();
	button_gpio();
	velOut_gpio2();
	velOut_gpio();
	timer_100us();
	init_motor_speed_timer2();
	init_motor_speed_timer();
	TM_PWM_Init2();
	TM_PWM_Init();
	int_GPIO_R();
	int_GPIO_L();
	init_GPIO_speed_difference();
	init_GPIO_ADC();
	init_adc();
	ini_dma();
	init_TIM6_ON();
	timer_1ms();

	//SDRAM_Init();

	//FMC_SDRAMWriteProtectionConfig(FMC_Bank2_SDRAM, DISABLE);

	LCD_Init();
	LCD_LayerInit();
	LTDC_Cmd(ENABLE);
	LTDC_LayerPixelFormat(LTDC_Layer1, LTDC_Pixelformat_ARGB4444);
	LTDC_LayerPixelFormat(LTDC_Layer2, LTDC_Pixelformat_ARGB4444);
	LTDC_ReloadConfig(LTDC_VBReload);

	//TIM_Cmd(TIM2, ENABLE);
	//TIM_Cmd(TIM9, ENABLE);
	//TIM_Cmd(TIM5, ENABLE);

	//STM_EVAL_LEDInit(LED3);
	STM_EVAL_LEDInit(LED4);

	//STM_EVAL_LEDOn(LED3);
	STM_EVAL_LEDOff(LED4);
	STM_EVAL_LEDOn(LED4);
	//set_buffer(LCD_FRAME_BUFFER + BUFFER_OFFSET);
	pintaFons();
	set_buffer(LCD_FRAME_BUFFER + BUFFER_OFFSET);
	EsborraPantalla(0x0, 0xF,0xF,0xF);

	init_circularBuffer(&dataBufferX);
	init_circularBuffer(&dataBufferY);

	/* Infinite loop */
	while (1) {

		if(fase3 > 0){
			fase3 = 0;
			volatile static float val1 = 0;
			volatile static char numberOfValues = 0;
			volatile static float val2 = 0;

			numberOfValues++;
			val1 += finalValue1;
			val2 += finalValue2;

			if (numberOfValues >= 9){
				numberOfValues = 0;
				val1 /= 10;
				val2 /= 10;

				ring_buffer_queue(&dataBufferX, val1);
				ring_buffer_queue(&dataBufferY, val2);

				EsborraPantalla(0x0, 0xF,0xF,0xF);

				uint8_t i;
				for (i = 0; i < BUFFER_SIZE; i++){
					float data;
					if (ring_buffer_get_data(&dataBufferX, &data, i)){
						uint16_t aux = (uint16_t) (195+(10*(data)));
						SetPixel((uint16_t)(101+i), aux, 0xFF, 0, 0, 0xFF);
					}else{
						break;
					}
				}

				for (i = 0; i < BUFFER_SIZE; i++){
					float data;
					if (ring_buffer_get_data(&dataBufferY, &data, i)){
						SetPixel((uint16_t) 45+(10*(data)), 35+i, 0xFF, 0xFF, 0, 0);
					}else{
						break;
					}
				}

				DibuixaBitmap ((uint16_t) 200 + (15*val2), (uint16_t) 76 + (15*val1) , 0xFF, 0xFF, 0, 0);

				val1 = val2 = 0;
			}
		}

	}
}

/*
 * Callback used by stm324xg_eval_i2c_ee.c.
 * Refer to stm324xg_eval_i2c_ee.h for more info.
 */
uint32_t sEE_TIMEOUT_UserCallback(void) {
	/* TODO, implement your code here */
	while (1) {
	}
}
